---
title: Database Architecture
description: How we configure and use Xata (managed PostgreSQL) and Drizzle ORM for our data layer.
---

We use **Xata** as a managed PostgreSQL-as-a-Service provider. Our application connects to Xata via a standard Postgres connection string, and we use **Drizzle ORM** for a type-safe, schema-driven interface.

---

## Environment Configuration

Add the Xata connection URL to your `.env`:

```bash
# .env
DATABASE_URL="postgres://<username>:<password>@<workspace>.xata.sh/db/toystore?branchName=main"
```

Drizzle will read `process.env.DATABASE_URL` when initializing.

---

## Drizzle ORM Initialization

We create a Postgres connection pool and pass it to Drizzle along with our schema definitions:

```ts
// src/db.ts
import dotenv from "dotenv";
import { Pool } from "pg";
import { drizzle } from "drizzle-orm/node-postgres";
import { Users, Customers, Products, Orders, OrderItems } from "./schema";

dotenv.config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 10,
});

export const db = drizzle(pool, {
  schema: {
    Users,
    Customers,
    Products,
    Orders,
    OrderItems,
  },
});
```

---

## Schema Definitions

We define enums and tables using Drizzle's Postgres core API:

```ts
// src/schema.ts
import {
  pgTable,
  pgEnum,
  uuid,
  varchar,
  text,
  integer,
  numeric,
  timestamp,
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";

// Enums
export const userRole = pgEnum("user_role", ["admin", "manager"]);
export const orderStatus = pgEnum("order_status", [
  "pending",
  "processing",
  "shipped",
  "delivered",
  "cancelled",
]);
export const categories = pgEnum("category", [
  "trucks",
  "lego_sets",
  "scooters",
  "stuffed_animals",
  "dolls",
  "kitchen_sets",
  "jewelry_kits",
]);

// Users
export const Users = pgTable("users", {
  id: uuid("id").defaultRandom().primaryKey(),
  username: varchar("username", { length: 50 }).notNull().unique(),
  email: varchar("email", { length: 100 }).notNull().unique(),
  passwordHash: varchar("password_hash", { length: 255 }).notNull(),
  role: userRole("role").notNull(),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Customers
export const Customers = pgTable("customers", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: varchar("name", { length: 100 }).notNull(),
  email: varchar("email", { length: 100 }).notNull().unique(),
  phone: varchar("phone", { length: 20 }),
  street: varchar("street", { length: 200 }),
  city: varchar("city", { length: 100 }),
  state: varchar("state", { length: 100 }),
  postalCode: varchar("postal_code", { length: 20 }),
  country: varchar("country", { length: 100 }),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Products
export const Products = pgTable("products", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: varchar("name", { length: 150 }).notNull(),
  description: text("description"),
  price: numeric("price", { precision: 10, scale: 2 }).notNull(),
  category: categories("category").notNull(),
  imageUrl: varchar("image_url", { length: 255 }),
  stockQuantity: integer("stock_quantity").default(0).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Orders
export const Orders = pgTable("orders", {
  id: uuid("id").defaultRandom().primaryKey(),
  customerId: uuid("customer_id")
    .notNull()
    .references(() => Customers.id, { onDelete: "cascade" }),
  orderDate: timestamp("order_date", { withTimezone: true })
    .defaultNow()
    .notNull(),
  status: orderStatus("status").notNull(),
  totalAmount: numeric("total_amount", { precision: 12, scale: 2 }).notNull(),
  scheduledDeliveryDate: timestamp("scheduled_delivery_date", {
    withTimezone: true,
  })
    .default(sql`CURRENT_TIMESTAMP + INTERVAL '14 days'`)
    .notNull(),
  dateDelivered: timestamp("date_delivered", { withTimezone: true }).default(
    sql`CURRENT_TIMESTAMP + INTERVAL '16 days'`
  ),
  deliveryStreet: varchar("delivery_street", { length: 200 }).default(""),
  deliveryCity: varchar("delivery_city", { length: 100 }).default(""),
  deliveryState: varchar("delivery_state", { length: 100 }).default(""),
  deliveryPostal: varchar("delivery_postal", { length: 20 }).default(""),
  deliveryCountry: varchar("delivery_country", { length: 100 }).default(""),
});

// Order Items
export const OrderItems = pgTable("order_items", {
  id: uuid("id").defaultRandom().primaryKey(),
  orderId: uuid("order_id")
    .notNull()
    .references(() => Orders.id, { onDelete: "cascade" }),
  productId: uuid("product_id")
    .notNull()
    .references(() => Products.id),
  quantity: integer("quantity").notNull(),
  unitPrice: numeric("unit_price", { precision: 10, scale: 2 }).notNull(),
  totalPrice: numeric("total_price", { precision: 12, scale: 2 }).notNull(),
});
```

---

## Migrations with Drizzle Kit

We version control schema changes and generate SQL migrations using **drizzle-kit**:

```json
// package.json (scripts)
{
  "generate": "drizzle-kit generate",
  "migrate": "drizzle-kit migrate"
}
```

- **`npm run generate`** inspects your `schema.ts` and creates a migration file in `drizzle/`.
- **`npm run migrate`** applies pending migrations to your Xata database.

---

This setup gives you a fully typed, versioned, and managed data layer on top of Xataâ€™s Postgres service.
